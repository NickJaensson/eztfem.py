# Generalized Newtonian problem on a unit square
# Poiseuille flow generated by a traction (pressure) difference
# Flow rate computation.

import numpy as np
import eztfem as ezt
from func import func
from traction_func import traction_func
from scipy.sparse.linalg import spsolve
from gn_elements import gn_elem


def main():

    # create mesh

    print('mesh')
    mesh = ezt.quadrilateral2d([2, 10], 'tria6')

    # define the problem

    print('problem_definition')
    elementdof = np.array([[2, 2, 2, 2, 2, 2],
                           [1, 0, 1, 0, 1, 0],
                           [1, 1, 1, 1, 1, 1]], dtype=int).transpose()
    problem = ezt.Problem(mesh, elementdof, nphysq=2)

    epsu = 1e-6
    epsp = 1e-6
    itermax = 100

    for iter in range(itermax):

        # define Gauss integration and basis functions

        user = ezt.User()
        shape = 'triangle'

        print('gauss_legendre')
        user.xr, user.wg = ezt.gauss_legendre(shape, p=3)

        print('basis_function phi')
        user.phi, user.dphi = ezt.basis_function(shape, 'P2', user.xr)

        print('basis_function psi')
        user.psi, _ = ezt.basis_function(shape, 'P1', user.xr)

        # user struct for setting problem coefficients, ...

        user.coorsys = 0
        user.funcnr = 0
        user.func = func  # not used when funcnr == 0

        # assemble the system matrix and vector

        # TODO set correct material parameters below

        if (iter == 0):
            # Newtonian starting vector
            user.mu = 1
            A, f = ezt.build_system(mesh, problem, ezt.stokes_elem, user)
        else:
            # gen Newtonian
            user.u = u  #  solution from previous iteration
            user.gnmodel = 1  # 1: power-law, 2: Carreau, 3: Carreau-Yasuda
            user.m = 1
            user.n = 0.5
            user.eta0 = 1
            user.etainf = 1e-3
            user.llambda = 1
            user.a = 2
            A, f = ezt.build_system(mesh, problem, gn_elem, user)

        # define Gauss integration and basis functions (for boundary integral)

        print('gauss_legendre')
        [xr, user.wg] = ezt.gauss_legendre('line', n=3)

        print('basis_function phi')
        [user.phi, user.dphi] = ezt.basis_function('line', 'P2', xr)

        # add natural boundary condition

        print('add_boundary_elements')
        user.funcnr = 1
        user.func = traction_func
        ezt.add_boundary_elements(mesh, problem, f, ezt.stokes_natboun_curve,
                                  user, physqrow=[0], curve=3)

        # define essential boundary conditions (Dirichlet)

        print('define_essential')
        iess = ezt.define_essential(mesh, problem, 'curves', [0, 2], degfd=0)
        iess = ezt.define_essential(mesh, problem, 'curves', [0, 1, 2, 3],
                                    degfd=1, iessp=iess)

        # zero bc values

        uess = np.zeros(problem.numdegfd)

        # apply essential boundary conditions to the system

        print('apply_essential')
        ezt.apply_essential(A, f, uess, iess)

        # solve the system

        print('solve')
        u = spsolve(A.tocsr(), f)

    #   test convergence of velocity and pressure

        if (iter > 0):
            idx, _ = ezt.pos_array(problem, [i for i in range(mesh.nnodes)])
            delu = max(abs(u[idx[0]] - user.u[idx[0]])) / max(abs(u[idx[0]]))
            delp = max(abs(u[idx[1]] - user.u[idx[1]])) / max(abs(u[idx[1]]))
            print(f'iteration {iter}: delu {delu:.4e} delp {delp:.4e}')
            if (delu < epsu and delp < epsp):
                print(f'Convergence at iteration {iter} \n')
                break
        else:
            print(f'iteration {iter}: Stokes solution')

    else:  # no-break
        raise RuntimeError('Iteration did not converge')

    # flow rate

    user.u = u
    flowrate = ezt.integrate_boundary_elements(mesh,
                                               problem,
                                               ezt.stokes_flowrate_curve,
                                               user, curve=1)

    print('flowrate = ', flowrate)

    # Pressure in all nodes for plotting

    print('pressure in nodes')
    xr = ezt.refcoor_nodal_points(mesh)
    user.psi, _ = ezt.basis_function('triangle', 'P1', xr)
    user.u = u
    pressure = ezt.deriv_vector(mesh, problem, ezt.stokes_pressure, user)

    # derivatives of the velocity

    print('velocity derivatives')
    xr = ezt.refcoor_nodal_points(mesh)
    user.phi, user.dphi = ezt.basis_function('triangle', 'P2', xr)
    user.u = u

    user.comp = 0  # dudx
    dudx = ezt.deriv_vector(mesh, problem, ezt.stokes_deriv, user)
    user.comp = 1  # dudy
    dudy = ezt.deriv_vector(mesh, problem, ezt.stokes_deriv, user)
    user.comp = 2  # dvdx
    dvdx = ezt.deriv_vector(mesh, problem, ezt.stokes_deriv, user)
    user.comp = 3  # dvdy
    dvdy = ezt.deriv_vector(mesh, problem, ezt.stokes_deriv, user)
    user.comp = 4  # dvdx - dudy = vorticity
    omega = ezt.deriv_vector(mesh, problem, ezt.stokes_deriv, user)
    user.comp = 6  # divu, divergence of the velocity field
    divu = ezt.deriv_vector(mesh, problem, ezt.stokes_deriv, user)
    user.comp = 7  # gammadot, effective strain rate = sqrt(2II_D)
    gammadot = ezt.deriv_vector(mesh, problem, ezt.stokes_deriv, user)

    return flowrate, mesh, problem, u


if __name__ == '__main__':
    main()